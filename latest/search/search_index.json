{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pyFlies A Domain-Specific Language (DSL) for designing experiments in psychology pyFlies is a language tailored for designing of experiments in psychology. These kind of languages are often called Domain-Specific Languages - DSLs. The aim of the language is to be highly readable and simple to learn and to focus on capturing the essence of the experiment while leaving the details to the compiler/code generator. A code for various run-time platforms can be generated from the experiment description. Currently PsychoPy is fully supported and we plan to build generators for other targets. Features: High-level. Easy to write and read. Experiments can be defined in minutes. From experiment description a source code for various platforms can be automatically generated. Declarative language. Specify what needs to be done and leave how part to the pyFlies compiler. Integrates in VS Code , one of the most popular code editor today with a huge number of extensions for all sorts of file editing tasks. Written in Python programming language. Easy to extend. Generators are plugins which can be developed independently. Fully free and open source. GPL license. Hosted on github . Easy to contribute to. Contributions are welcomed! Overview video Click on the image bellow to see a short (~3 min) overview video. For a longer introduction please see tutorial videos. Getting started Installation Install Python and check that it is available on the command line by running: python --version It is recommended to use Python virtual environments to isolate different set of Python libraries. Create virtual environment for pyFlies by running: python -m venv pyflies-venv This will create folder pyflies-venv where your libraries will be installed. You need to activate virtual environment before usage: source pyflies-venv/bin/activate (for Linux and other POSIX systems) pyflies-venv\\Scripts\\activate.bat (for Windows) Now, you can install pyFlies and generator for PsychoPy with: pip install pyflies-psychopy To verify that pyFlies is installed you can run: textx list-generators You can see in the output that the generator pyflies -> psychopy is available. pyFlies specifications are pure text and can be edited by any textual editor but for a good experience (especially with tables) it is recommended that pyFlies extension for VS Code is used. Install VS Code either for you OS package manager or by going to VS Code download page and downloading package for your operating system. In the list of extensions find pyFlies and click on install . Note In order to run your experiments you need to install software for the target platform you want to generate code for (currently PsychoPy only). Note You can watch the process of installation in this video . In the video we are using Linux but most of the information is valid for other OSes. Video tutorials The best way to start with pyFlies is by watching some of our video tutorials . Try examples Clone or download pyFlies repo . Unpack and load examples from examples folder in the VS Code editor. Update experiment definition to your taste. Generate and run experiment. Planned features Besides language improvement which we are constantly work on, there are two bigger features that will greatly improve overall user experience in working in the pyFlies editor: Running generators from the context menu in VS Code and getting feedback and errors. \"Smart\" code-completion and code navigation. Currently, we provide only code snippets which can help a lot but implementing Language Server Protocol for pyFlies we can get much better editing experience. For example, when you type exec -> editor can offer just the components, or when you are inside the component parameters editor can offer just the parameters for that component (without those that are already specified) with explanation extracted from the component description in the tooltip. Furthermore, navigation will enable to click on a variable and jump to its definition. Discuss, ask questions For all questions, ideas, feature requests and bug report please use the GitHub issue tracker . Citing If you are using PyFlies in your research or you are referring to PyFlies in your papers please cite this paper : Dejanovi\u0107, I.; Dejanovi\u0107, M.; Vidakovi\u0107, J.; Nikoli\u0107, S. PyFlies: A Domain-Specific Language for Designing Experiments in Psychology. Appl. Sci. 2021, 11, 7823. https://doi.org/10.3390/app11177823 @Article{app11177823, AUTHOR = {Dejanovi\u0107, Igor and Dejanovi\u0107, Mirjana and Vidakovi\u0107, Jovana and Nikoli\u0107, Sini\u0161a}, TITLE = {PyFlies: A Domain-Specific Language for Designing Experiments in Psychology}, JOURNAL = {Applied Sciences}, VOLUME = {11}, YEAR = {2021}, NUMBER = {17}, ARTICLE-NUMBER = {7823}, URL = {https://www.mdpi.com/2076-3417/11/17/7823}, ISSN = {2076-3417}, DOI = {10.3390/app11177823} } Screenshots (click for a popup) Editing specification Experiment is created and modified in a convenient to use editor. Generated log From an experiment specification a full log of the experiment flow is generated which can be used to investigate and debug the experiment. Generated PsychoPy code From an experiment specification Python code for PsychoPy is generated which is used to run the experiment. pyFlies icon is based on an icon licensed by CC BY 3.0 from Icon Fonts .","title":"Home"},{"location":"#pyflies","text":"A Domain-Specific Language (DSL) for designing experiments in psychology pyFlies is a language tailored for designing of experiments in psychology. These kind of languages are often called Domain-Specific Languages - DSLs. The aim of the language is to be highly readable and simple to learn and to focus on capturing the essence of the experiment while leaving the details to the compiler/code generator. A code for various run-time platforms can be generated from the experiment description. Currently PsychoPy is fully supported and we plan to build generators for other targets. Features: High-level. Easy to write and read. Experiments can be defined in minutes. From experiment description a source code for various platforms can be automatically generated. Declarative language. Specify what needs to be done and leave how part to the pyFlies compiler. Integrates in VS Code , one of the most popular code editor today with a huge number of extensions for all sorts of file editing tasks. Written in Python programming language. Easy to extend. Generators are plugins which can be developed independently. Fully free and open source. GPL license. Hosted on github . Easy to contribute to. Contributions are welcomed!","title":"pyFlies"},{"location":"#overview-video","text":"Click on the image bellow to see a short (~3 min) overview video. For a longer introduction please see tutorial videos.","title":"Overview video"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#installation","text":"Install Python and check that it is available on the command line by running: python --version It is recommended to use Python virtual environments to isolate different set of Python libraries. Create virtual environment for pyFlies by running: python -m venv pyflies-venv This will create folder pyflies-venv where your libraries will be installed. You need to activate virtual environment before usage: source pyflies-venv/bin/activate (for Linux and other POSIX systems) pyflies-venv\\Scripts\\activate.bat (for Windows) Now, you can install pyFlies and generator for PsychoPy with: pip install pyflies-psychopy To verify that pyFlies is installed you can run: textx list-generators You can see in the output that the generator pyflies -> psychopy is available. pyFlies specifications are pure text and can be edited by any textual editor but for a good experience (especially with tables) it is recommended that pyFlies extension for VS Code is used. Install VS Code either for you OS package manager or by going to VS Code download page and downloading package for your operating system. In the list of extensions find pyFlies and click on install . Note In order to run your experiments you need to install software for the target platform you want to generate code for (currently PsychoPy only). Note You can watch the process of installation in this video . In the video we are using Linux but most of the information is valid for other OSes.","title":"Installation"},{"location":"#video-tutorials","text":"The best way to start with pyFlies is by watching some of our video tutorials .","title":"Video tutorials"},{"location":"#try-examples","text":"Clone or download pyFlies repo . Unpack and load examples from examples folder in the VS Code editor. Update experiment definition to your taste. Generate and run experiment.","title":"Try examples"},{"location":"#planned-features","text":"Besides language improvement which we are constantly work on, there are two bigger features that will greatly improve overall user experience in working in the pyFlies editor: Running generators from the context menu in VS Code and getting feedback and errors. \"Smart\" code-completion and code navigation. Currently, we provide only code snippets which can help a lot but implementing Language Server Protocol for pyFlies we can get much better editing experience. For example, when you type exec -> editor can offer just the components, or when you are inside the component parameters editor can offer just the parameters for that component (without those that are already specified) with explanation extracted from the component description in the tooltip. Furthermore, navigation will enable to click on a variable and jump to its definition.","title":"Planned features"},{"location":"#discuss-ask-questions","text":"For all questions, ideas, feature requests and bug report please use the GitHub issue tracker .","title":"Discuss, ask questions"},{"location":"#citing","text":"If you are using PyFlies in your research or you are referring to PyFlies in your papers please cite this paper : Dejanovi\u0107, I.; Dejanovi\u0107, M.; Vidakovi\u0107, J.; Nikoli\u0107, S. PyFlies: A Domain-Specific Language for Designing Experiments in Psychology. Appl. Sci. 2021, 11, 7823. https://doi.org/10.3390/app11177823 @Article{app11177823, AUTHOR = {Dejanovi\u0107, Igor and Dejanovi\u0107, Mirjana and Vidakovi\u0107, Jovana and Nikoli\u0107, Sini\u0161a}, TITLE = {PyFlies: A Domain-Specific Language for Designing Experiments in Psychology}, JOURNAL = {Applied Sciences}, VOLUME = {11}, YEAR = {2021}, NUMBER = {17}, ARTICLE-NUMBER = {7823}, URL = {https://www.mdpi.com/2076-3417/11/17/7823}, ISSN = {2076-3417}, DOI = {10.3390/app11177823} }","title":"Citing"},{"location":"#screenshots-click-for-a-popup","text":"","title":"Screenshots (click for a popup)"},{"location":"#editing-specification","text":"Experiment is created and modified in a convenient to use editor.","title":"Editing specification"},{"location":"#generated-log","text":"From an experiment specification a full log of the experiment flow is generated which can be used to investigate and debug the experiment.","title":"Generated log"},{"location":"#generated-psychopy-code","text":"From an experiment specification Python code for PsychoPy is generated which is used to run the experiment. pyFlies icon is based on an icon licensed by CC BY 3.0 from Icon Fonts .","title":"Generated PsychoPy code"},{"location":"components/","text":"Component types Components are internally defined using DSL for component specification. Currently this DSL is not exposed to end users but we have plan to do so in the future to support specification of additional components that are not provided by pyFlies. We must assert that making non-standard components will make experiment specification non-portable across different target generators but it could be invaluable in the situations where non-standard components are required and portability is not an issue. This page is generated on 2020-10-29 14:51:41 from component descriptions during build so what is documented here is what pyFlies actually uses: base // Base abstract components that define common properties abstract component visual \"\"\" The definition of parameters used by all visual stimuli \"\"\" { param position:point = (0, 0) \"\"\" The position of the component. By default center of the screen. \"\"\" param size:[symbol, int] = 20 \"\"\" The size of the component. May be given in descriptive way or as a size in the coordinate space. \"\"\" param color:[symbol, color] = #ffffff \"\"\" This color is used for border of the component. Default is white. \"\"\" param fillColor:[symbol, color] = #ffffff \"\"\" This color is used to fill the interior of the visual component. Default is white. \"\"\" } abstract component audible \"\"\" This is an abstract component that should be inherited by all components that play sounds. \"\"\" {} abstract component input \"\"\" This is an abstract component that should be inherited by all components that accepts input from the subject. \"\"\" {} cross component cross extends visual \"\"\" Usually used as a fixation point \"\"\" {} circle component circle extends visual \"\"\" Visual stimuli in the shape of a circle. \"\"\" { param radius:int = 20 \"\"\" The radius of the circle. \"\"\" } text component text extends visual \"\"\" A component for displaying text \"\"\" { param content: string = 'default text' \"\"\" A mandatory content for display \"\"\" } line component line extends visual \"\"\" Visual stimuli representing line between two points \"\"\" { param from:[symbol, point] = (-50, 0) \"\"\" The start point of the line shape \"\"\" param to:[symbol, point] = (50, 0) \"\"\" The end point of the line shape \"\"\" } rectangle component rectangle extends visual \"\"\" Visual stimuli in the form of rectangle \"\"\" { param size:[symbol, point] = (20, 20) \"\"\" Override `size` to be of point type representing width and height. 0 for height means 'keep aspect ratio'. \"\"\" } image component image extends visual \"\"\" A component that displays image loaded from file \"\"\" { param file: string = 'default path' \"\"\" A file path relative to the model file. \"\"\" param ori: int = 0 \"\"\" Orijentation in degrees. \"\"\" } audio component audio extends audible \"\"\" Plays audio loaded from the given file \"\"\" { param file: string = 'default path' \"\"\" The file to load audio from \"\"\" } sound component sound extends audible \"\"\" Plays sound of the given frequency \"\"\" { param freq: int = 500 \"\"\" The frequency of the sound \"\"\" } keyboard component keyboard extends input \"\"\" Component for implementing keyboard input \"\"\" { param valid:[symbol, list] = space \"\"\" What is considered a valid keystroke in the trial. Can be a list of valid keys. \"\"\" param correct:[symbol, list] = space \"\"\" What is a correct response for this trial. Can be a single key or a list of keys. If this parameter is provided, must be found in valid list of keys. If not given any key from the list of valid keys is considered correct. \"\"\" } mouse component mouse extends input \"\"\" Component for implementing mouse input \"\"\" { param target:[symbol, list] = none \"\"\" A component name or a list of component names which represents valid targets. If target is none than any click is valid. \"\"\" }","title":"Components"},{"location":"components/#component-types","text":"Components are internally defined using DSL for component specification. Currently this DSL is not exposed to end users but we have plan to do so in the future to support specification of additional components that are not provided by pyFlies. We must assert that making non-standard components will make experiment specification non-portable across different target generators but it could be invaluable in the situations where non-standard components are required and portability is not an issue. This page is generated on 2020-10-29 14:51:41 from component descriptions during build so what is documented here is what pyFlies actually uses:","title":"Component types"},{"location":"components/#base","text":"// Base abstract components that define common properties abstract component visual \"\"\" The definition of parameters used by all visual stimuli \"\"\" { param position:point = (0, 0) \"\"\" The position of the component. By default center of the screen. \"\"\" param size:[symbol, int] = 20 \"\"\" The size of the component. May be given in descriptive way or as a size in the coordinate space. \"\"\" param color:[symbol, color] = #ffffff \"\"\" This color is used for border of the component. Default is white. \"\"\" param fillColor:[symbol, color] = #ffffff \"\"\" This color is used to fill the interior of the visual component. Default is white. \"\"\" } abstract component audible \"\"\" This is an abstract component that should be inherited by all components that play sounds. \"\"\" {} abstract component input \"\"\" This is an abstract component that should be inherited by all components that accepts input from the subject. \"\"\" {}","title":"base"},{"location":"components/#cross","text":"component cross extends visual \"\"\" Usually used as a fixation point \"\"\" {}","title":"cross"},{"location":"components/#circle","text":"component circle extends visual \"\"\" Visual stimuli in the shape of a circle. \"\"\" { param radius:int = 20 \"\"\" The radius of the circle. \"\"\" }","title":"circle"},{"location":"components/#text","text":"component text extends visual \"\"\" A component for displaying text \"\"\" { param content: string = 'default text' \"\"\" A mandatory content for display \"\"\" }","title":"text"},{"location":"components/#line","text":"component line extends visual \"\"\" Visual stimuli representing line between two points \"\"\" { param from:[symbol, point] = (-50, 0) \"\"\" The start point of the line shape \"\"\" param to:[symbol, point] = (50, 0) \"\"\" The end point of the line shape \"\"\" }","title":"line"},{"location":"components/#rectangle","text":"component rectangle extends visual \"\"\" Visual stimuli in the form of rectangle \"\"\" { param size:[symbol, point] = (20, 20) \"\"\" Override `size` to be of point type representing width and height. 0 for height means 'keep aspect ratio'. \"\"\" }","title":"rectangle"},{"location":"components/#image","text":"component image extends visual \"\"\" A component that displays image loaded from file \"\"\" { param file: string = 'default path' \"\"\" A file path relative to the model file. \"\"\" param ori: int = 0 \"\"\" Orijentation in degrees. \"\"\" }","title":"image"},{"location":"components/#audio","text":"component audio extends audible \"\"\" Plays audio loaded from the given file \"\"\" { param file: string = 'default path' \"\"\" The file to load audio from \"\"\" }","title":"audio"},{"location":"components/#sound","text":"component sound extends audible \"\"\" Plays sound of the given frequency \"\"\" { param freq: int = 500 \"\"\" The frequency of the sound \"\"\" }","title":"sound"},{"location":"components/#keyboard","text":"component keyboard extends input \"\"\" Component for implementing keyboard input \"\"\" { param valid:[symbol, list] = space \"\"\" What is considered a valid keystroke in the trial. Can be a list of valid keys. \"\"\" param correct:[symbol, list] = space \"\"\" What is a correct response for this trial. Can be a single key or a list of keys. If this parameter is provided, must be found in valid list of keys. If not given any key from the list of valid keys is considered correct. \"\"\" }","title":"keyboard"},{"location":"components/#mouse","text":"component mouse extends input \"\"\" Component for implementing mouse input \"\"\" { param target:[symbol, list] = none \"\"\" A component name or a list of component names which represents valid targets. If target is none than any click is valid. \"\"\" }","title":"mouse"},{"location":"condition-tables/","text":"Condition tables Condition tables define one or more variables in each column and their values for conditions in each row. They are used to specify values of related variables given in a row representing a certain state. These tables are used in test defintion and for repeat with form of repetition. In the test definition each row of the table represent a single test trial. While in repeat with statement each row represent a single cycle through the repeat loop where the values of the variables will be from the corresponding table row. | number | parity | |--------------|----------| | numbers loop | parities | The header of the table contains variable names ( number and parity ) while the cells of the rest of the table contain expressions . Tables expansion Tables are usually, although not necessary, written in a compact form which is expanded during compilation. This compact representation is shorter, require less screen space and gives more flexibility in adding new variables and altering the number of conditions. Note Tables are written in pure text and can be edited with any text editor but for a convenience pyFlies VS Code editor has auto-formatting and navigation capabilities which makes editing much more pleasant. To understand table expansion lets look at some examples. Lets say we want to loop through several colors and for each color to loop through some directions to explore all possible options. We can do that in the following way: | color | direction | | ----------------------- | ------------------ | | [red, green, blue] loop | [left, right] loop | Expressions in both columns are loop expressions over list of symbols. Loop expressions are evaluated and nested from left to right, so the table in expanded form will be: | color | direction | | ----- | --------- | | red | left | | red | right | | green | left | | green | right | | blue | left | | blue | right | Tip Use log generator to produce expanded tables, and other interesting information about your experiment. Now, lets expand the table a bit. Lets suppose that we want a new table variable called congruency that has value congruent if color is green and incongruent otherwise. For this we can use if expression: | color | direction | congruency | | ----------------------- | ------------------ | -------------------------------------------- | | [red, green, blue] loop | [left, right] loop | congruent if color == green else incongruent | See how we referenced color variable in the congruency column and compared its value with the symbol green . Now, the expanded table will be: | color | direction | congruency | | ----- | --------- | ----------- | | red | left | incongruent | | red | right | incongruent | | green | left | congruent | | green | right | congruent | | blue | left | incongruent | | blue | right | incongruent | Tip To make table expressions simpler you can always define variables which can hold a used sequence or a whole expression. For example: colors = [red, green, blue] directions = [left, right] is_congruent = congruent if color == green else incongruent test MyTest { | index | color | direction | congruency | | ----- | ----------- | --------------- | ------------ | | 1..8 | colors loop | directions loop | is_congruent | } Now, lets say we want to introduce index variable which will be the number of the current row. In compact form it is easy: | index | color | direction | congruency | | ----- | ----------------------- | ------------------ | -------------------------------------------- | | 1..8 | [red, green, blue] loop | [left, right] loop | congruent if color == green else incongruent | Notice the use of the range type as the expression in the index column. If we have a sequence-like type (list or range) then the value will cycle, i.e. for each row the next value from the sequence will be used until the sequence is exhausted. After that the sequence will start from the beginning. So, we can say that loop expression take precedence. If the row has loop expressions they will be used, from left to right, to drive the row creation and other sequences will be fillers. If no loop exists in the row, sequences will expand until the longest is exhausted. Consider this example: | color | direction | | ------------------ | ------------- | | [red, green, blue] | [left, right] | Since we have no loops the table will expand to three rows, until the colors are exhausted while the direction will cycle: | color | direction | | ----- | --------- | | red | left | | green | right | | blue | left | In the previous example where we added index column with range 1..8 , we could easily specify larger range 1..100 and the result will be the same. That is because we have loops in the column and the index is just the filler so that after row 8 is created all loops are over and the expansion stops. We can specify multiple rows even in a compact form, and can mix and match constant rows with expression based. For example: | index | color | direction | | ------ | ----------------------- | ------------------ | | 1..2 | [orange, brown] | up | | 3..100 | [red, green, blue] loop | [left, right] loop | will expand to: | index | color | direction | |-------|--------|-----------| | 1 | orange | up | | 2 | brown | up | | 3 | red | left | | 4 | red | right | | 5 | green | left | | 6 | green | right | | 7 | blue | left | So, the first row will expand and then the second. Now, you can see that creating table of conditions is easy and very powerful. Tip pyFlies provides CSV generator, which is a standard textX based generator like all others, that you can use to create condition table using pyFlies powerful syntax and table expansion and export it for use in other tools.","title":"Condition tables"},{"location":"condition-tables/#condition-tables","text":"Condition tables define one or more variables in each column and their values for conditions in each row. They are used to specify values of related variables given in a row representing a certain state. These tables are used in test defintion and for repeat with form of repetition. In the test definition each row of the table represent a single test trial. While in repeat with statement each row represent a single cycle through the repeat loop where the values of the variables will be from the corresponding table row. | number | parity | |--------------|----------| | numbers loop | parities | The header of the table contains variable names ( number and parity ) while the cells of the rest of the table contain expressions .","title":"Condition tables"},{"location":"condition-tables/#tables-expansion","text":"Tables are usually, although not necessary, written in a compact form which is expanded during compilation. This compact representation is shorter, require less screen space and gives more flexibility in adding new variables and altering the number of conditions. Note Tables are written in pure text and can be edited with any text editor but for a convenience pyFlies VS Code editor has auto-formatting and navigation capabilities which makes editing much more pleasant. To understand table expansion lets look at some examples. Lets say we want to loop through several colors and for each color to loop through some directions to explore all possible options. We can do that in the following way: | color | direction | | ----------------------- | ------------------ | | [red, green, blue] loop | [left, right] loop | Expressions in both columns are loop expressions over list of symbols. Loop expressions are evaluated and nested from left to right, so the table in expanded form will be: | color | direction | | ----- | --------- | | red | left | | red | right | | green | left | | green | right | | blue | left | | blue | right | Tip Use log generator to produce expanded tables, and other interesting information about your experiment. Now, lets expand the table a bit. Lets suppose that we want a new table variable called congruency that has value congruent if color is green and incongruent otherwise. For this we can use if expression: | color | direction | congruency | | ----------------------- | ------------------ | -------------------------------------------- | | [red, green, blue] loop | [left, right] loop | congruent if color == green else incongruent | See how we referenced color variable in the congruency column and compared its value with the symbol green . Now, the expanded table will be: | color | direction | congruency | | ----- | --------- | ----------- | | red | left | incongruent | | red | right | incongruent | | green | left | congruent | | green | right | congruent | | blue | left | incongruent | | blue | right | incongruent | Tip To make table expressions simpler you can always define variables which can hold a used sequence or a whole expression. For example: colors = [red, green, blue] directions = [left, right] is_congruent = congruent if color == green else incongruent test MyTest { | index | color | direction | congruency | | ----- | ----------- | --------------- | ------------ | | 1..8 | colors loop | directions loop | is_congruent | } Now, lets say we want to introduce index variable which will be the number of the current row. In compact form it is easy: | index | color | direction | congruency | | ----- | ----------------------- | ------------------ | -------------------------------------------- | | 1..8 | [red, green, blue] loop | [left, right] loop | congruent if color == green else incongruent | Notice the use of the range type as the expression in the index column. If we have a sequence-like type (list or range) then the value will cycle, i.e. for each row the next value from the sequence will be used until the sequence is exhausted. After that the sequence will start from the beginning. So, we can say that loop expression take precedence. If the row has loop expressions they will be used, from left to right, to drive the row creation and other sequences will be fillers. If no loop exists in the row, sequences will expand until the longest is exhausted. Consider this example: | color | direction | | ------------------ | ------------- | | [red, green, blue] | [left, right] | Since we have no loops the table will expand to three rows, until the colors are exhausted while the direction will cycle: | color | direction | | ----- | --------- | | red | left | | green | right | | blue | left | In the previous example where we added index column with range 1..8 , we could easily specify larger range 1..100 and the result will be the same. That is because we have loops in the column and the index is just the filler so that after row 8 is created all loops are over and the expansion stops. We can specify multiple rows even in a compact form, and can mix and match constant rows with expression based. For example: | index | color | direction | | ------ | ----------------------- | ------------------ | | 1..2 | [orange, brown] | up | | 3..100 | [red, green, blue] loop | [left, right] loop | will expand to: | index | color | direction | |-------|--------|-----------| | 1 | orange | up | | 2 | brown | up | | 3 | red | left | | 4 | red | right | | 5 | green | left | | 6 | green | right | | 7 | blue | left | So, the first row will expand and then the second. Now, you can see that creating table of conditions is easy and very powerful. Tip pyFlies provides CSV generator, which is a standard textX based generator like all others, that you can use to create condition table using pyFlies powerful syntax and table expansion and export it for use in other tools.","title":"Tables expansion"},{"location":"flow/","text":"Experiment flow Experiment flow is specified in the flow block given after all test/screens specification and it consists of a series of statements for executing a test, showing a screen or repeating a test or a statement block. Here is an example of how experiment flow may look like: flow { show Intro for 5000 execute Parity(practice true, random true) show Real // repeat test 2 times, each repetition will be randomized repeat 2 times Parity(random true) } Showing screens In the above example, we see that first the Intro screen is shown to the subject for 5s. for definition is optional and if not given screen will be displayed until the subject provide some input (keypress, mouse click etc.). We can pass arguments to screen which can be used to introduce variable parts in the screen content. For details see the screens section . Executing tests Each test definition may be executed many times during the course of the test. Test is executed with execute statement after which we give the name of the test and optionally argument values. execute is just an alias of repeat 1 time <test name> See the looping section for details on the repeat statement. Passing arguments to tests and screens As you may have notice in the above example, we may pass arguments to screens and tests. These arguments will be available as variables in the context of the test/screen. For example: execute Parity(practice true, random true, some_param 42) Argument can have any name and any value type. Two arguments of bool type have special meaning: practice and random . Default values of both those params are false . These params are applicable only to the test execution. If practice is set to true then the execution will not record any data. If random is set to true then the order of trials in the test will be randomized. Repeating A flow definition may contain repeat loops. The repeat loop can be specified for a single test execution or for a block of statements. repeat keyword define the looping statement. There are two form of repeat : repeat <x> times and repeat with . repeat <x> times This form of repeat is used to loop a test or a block of statements for the given number of times. Examples: repeat 5 times Posner(random true) repeat 3 times { screen Instructions for 10000 execute Posner } repeat blocks can be nested: repeat 3 times { screen Instructions for 10000 repeat 2 times { screen InnerBlockInstructions execute Posner } } repeat with This form of looping is used when we have a condition table and we want to execute a test or a block of statements for each row of the table. Variables from the table are available inside the looping block. Example: repeat { show instruction // 3 same blocks repeat 3 times { execute showImages show break for 1000 } } with | image_type | order | | ---------------- | ----- | | image_types loop | 1..2 | In this example we have a repeat with outer loop with a condition table given after the with keyword. image_types is a global variable defined, for example, as: image_types = [houses, faces] used here to expand the table . For each row of the table the block of statement will be executed and variables defined in the table ( image_type and order ) will be available inside the block. These variables will be propagated to all inner repeat loops and to all execution of tests and screens. This means that we can reference these two variables in the screen content and in the test expressions (e.g. component parameters in test definitions). For a full experiment specification take a look at the blocking example .","title":"Flow"},{"location":"flow/#experiment-flow","text":"Experiment flow is specified in the flow block given after all test/screens specification and it consists of a series of statements for executing a test, showing a screen or repeating a test or a statement block. Here is an example of how experiment flow may look like: flow { show Intro for 5000 execute Parity(practice true, random true) show Real // repeat test 2 times, each repetition will be randomized repeat 2 times Parity(random true) }","title":"Experiment flow"},{"location":"flow/#showing-screens","text":"In the above example, we see that first the Intro screen is shown to the subject for 5s. for definition is optional and if not given screen will be displayed until the subject provide some input (keypress, mouse click etc.). We can pass arguments to screen which can be used to introduce variable parts in the screen content. For details see the screens section .","title":"Showing screens"},{"location":"flow/#executing-tests","text":"Each test definition may be executed many times during the course of the test. Test is executed with execute statement after which we give the name of the test and optionally argument values. execute is just an alias of repeat 1 time <test name> See the looping section for details on the repeat statement.","title":"Executing tests"},{"location":"flow/#passing-arguments-to-tests-and-screens","text":"As you may have notice in the above example, we may pass arguments to screens and tests. These arguments will be available as variables in the context of the test/screen. For example: execute Parity(practice true, random true, some_param 42) Argument can have any name and any value type. Two arguments of bool type have special meaning: practice and random . Default values of both those params are false . These params are applicable only to the test execution. If practice is set to true then the execution will not record any data. If random is set to true then the order of trials in the test will be randomized.","title":"Passing arguments to tests and screens"},{"location":"flow/#repeating","text":"A flow definition may contain repeat loops. The repeat loop can be specified for a single test execution or for a block of statements. repeat keyword define the looping statement. There are two form of repeat : repeat <x> times and repeat with .","title":"Repeating"},{"location":"flow/#repeat-x-times","text":"This form of repeat is used to loop a test or a block of statements for the given number of times. Examples: repeat 5 times Posner(random true) repeat 3 times { screen Instructions for 10000 execute Posner } repeat blocks can be nested: repeat 3 times { screen Instructions for 10000 repeat 2 times { screen InnerBlockInstructions execute Posner } }","title":"repeat &lt;x&gt; times"},{"location":"flow/#repeat-with","text":"This form of looping is used when we have a condition table and we want to execute a test or a block of statements for each row of the table. Variables from the table are available inside the looping block. Example: repeat { show instruction // 3 same blocks repeat 3 times { execute showImages show break for 1000 } } with | image_type | order | | ---------------- | ----- | | image_types loop | 1..2 | In this example we have a repeat with outer loop with a condition table given after the with keyword. image_types is a global variable defined, for example, as: image_types = [houses, faces] used here to expand the table . For each row of the table the block of statement will be executed and variables defined in the table ( image_type and order ) will be available inside the block. These variables will be propagated to all inner repeat loops and to all execution of tests and screens. This means that we can reference these two variables in the screen content and in the test expressions (e.g. component parameters in test definitions). For a full experiment specification take a look at the blocking example .","title":"repeat with"},{"location":"generators/","text":"Running generators You can generate various content from pyFlies experiment specifications. pyFlies is built using textX tool for DSL development in Python so you can query what generators are available using textx command line tools. To see all installed generators use textx list-generators command: $ textx list-generators any -> dot textX[2.3.0.dev0] Generating dot visualizations from arbitrary models textX -> dot textX[2.3.0.dev0] Generating dot visualizations from textX grammars textX -> PlantUML textX[2.3.0.dev0] Generating PlantUML visualizations from textX grammars pyflies -> log pyflies[0.4.0.dev0] Generator for log/debug files. pyflies -> csv pyflies[0.4.0.dev0] Generator for CSV files from pyFlies tables. pyflies -> psychopy pyflies-psychopy[0.1.0.dev0] Generator for generating PsychoPy code from pyFlies descriptions You will see all generators installed in your Python environment. First column is in language -> target format and you can see here that we have three pyFlies generators registered: pyflies -> log -- produces log files from .pf files and is a builtin generator of the pyflies project . This generator is useful for debugging and overview of the course of your experiment. pyflies -> csv -- produces CSV files from condition tables specified in .pf files and is also a builtin generator provided by the pyflies project . This generator is useful if you want a quick way to produce CSV condition files to be used in other experiment tools. pyflies -> psychopy -- this generator produces PsychoPy Python code from .pf and is provided by pyflies-psychopy project To call generator use textx generate command: textx generate Posner.pf --target log --overwrite Here we generate log output from Posner.pf pyflies experiment. We use --overwrite to overwrite existing log file. textx generate Parity.pf --target psychopy --overwrite This will generate PsychoPy Python code ( Parity.py ) from Parity.pf pyflies file. textX uses pluggable architecture for languages and generators. Additional generators may be developed independently of the pyFlies project and registered in the environment by mere installation with pip .","title":"Running generators"},{"location":"generators/#running-generators","text":"You can generate various content from pyFlies experiment specifications. pyFlies is built using textX tool for DSL development in Python so you can query what generators are available using textx command line tools. To see all installed generators use textx list-generators command: $ textx list-generators any -> dot textX[2.3.0.dev0] Generating dot visualizations from arbitrary models textX -> dot textX[2.3.0.dev0] Generating dot visualizations from textX grammars textX -> PlantUML textX[2.3.0.dev0] Generating PlantUML visualizations from textX grammars pyflies -> log pyflies[0.4.0.dev0] Generator for log/debug files. pyflies -> csv pyflies[0.4.0.dev0] Generator for CSV files from pyFlies tables. pyflies -> psychopy pyflies-psychopy[0.1.0.dev0] Generator for generating PsychoPy code from pyFlies descriptions You will see all generators installed in your Python environment. First column is in language -> target format and you can see here that we have three pyFlies generators registered: pyflies -> log -- produces log files from .pf files and is a builtin generator of the pyflies project . This generator is useful for debugging and overview of the course of your experiment. pyflies -> csv -- produces CSV files from condition tables specified in .pf files and is also a builtin generator provided by the pyflies project . This generator is useful if you want a quick way to produce CSV condition files to be used in other experiment tools. pyflies -> psychopy -- this generator produces PsychoPy Python code from .pf and is provided by pyflies-psychopy project To call generator use textx generate command: textx generate Posner.pf --target log --overwrite Here we generate log output from Posner.pf pyflies experiment. We use --overwrite to overwrite existing log file. textx generate Parity.pf --target psychopy --overwrite This will generate PsychoPy Python code ( Parity.py ) from Parity.pf pyflies file. textX uses pluggable architecture for languages and generators. Additional generators may be developed independently of the pyFlies project and registered in the environment by mere installation with pip .","title":"Running generators"},{"location":"metrics/","text":"Metrics and units Although metrics and units are not hard-coded in any way and can be interpreted by target code generator in arbitrary ways, we should defined some common ground to be able to port experiments between platforms. pyFlies assumes the following metrics and units: for coordinate system we assume that center of the screen is (0, 0) and the screen extends 100 units in each direction where going up and right is a positive direction. colors are in standard CSS format - #<red two hex digits><green two hex digits><blue two hex digits> . E.g. #a489f3 . for time unit we assume miliseconds. Tip In the VS Code editor you can use various extensions to make your editing experience more pleasant. For example, for working with colors you can use Color Manager","title":"Metrics"},{"location":"metrics/#metrics-and-units","text":"Although metrics and units are not hard-coded in any way and can be interpreted by target code generator in arbitrary ways, we should defined some common ground to be able to port experiments between platforms. pyFlies assumes the following metrics and units: for coordinate system we assume that center of the screen is (0, 0) and the screen extends 100 units in each direction where going up and right is a positive direction. colors are in standard CSS format - #<red two hex digits><green two hex digits><blue two hex digits> . E.g. #a489f3 . for time unit we assume miliseconds. Tip In the VS Code editor you can use various extensions to make your editing experience more pleasant. For example, for working with colors you can use Color Manager","title":"Metrics and units"},{"location":"screens/","text":"Screens Screens are used to display instructions to the subject. Here is an example of a screen definition: screen Intro { Parity classification --------------------- This is a practice block. You will be presented with a digit. Press LEFT for odd and RIGHT for even digit. Press ENTER key for the start. } Each screen starts with a keyword screen after which we give a unique name for the screen which is used in show statements in the flow definition . The screen content is enclosed in curly braces. Most of the time screen content is just a plain static text but sometimes we need to show screen multiple times to the subject which contains almost the same content but with a slight changes. To support dynamic parts of the screen content it is piped through Jinja template engine and thus can contain variable parts which are filled when the screen is displayed . For example: As you can see we have used two variables in the screen definition: myparam and upper_bound . These variable can be defined globally at the beginning of the experiment or can be passed as arguments when the screen is displayed like: show AnExampleScreen(myparam hello, upper_bound 10) The screen will be rendered as: This is just a demonstration of parameter rendering inside screen. Here is a param that renders as \"hello\". And here is some looping from 1 to 9 1. Hello world! 2. Hello world! 3. Hello world! 4. Hello world! 5. Hello world! 6. Hello world! 7. Hello world! 8. Hello world! 9. Hello world! Special syntax used to interpolate variable part ( {{}} , {% for ... %} etc.) is defined by Jinja template engine end the full documentation is available on the project site .","title":"Screens"},{"location":"screens/#screens","text":"Screens are used to display instructions to the subject. Here is an example of a screen definition: screen Intro { Parity classification --------------------- This is a practice block. You will be presented with a digit. Press LEFT for odd and RIGHT for even digit. Press ENTER key for the start. } Each screen starts with a keyword screen after which we give a unique name for the screen which is used in show statements in the flow definition . The screen content is enclosed in curly braces. Most of the time screen content is just a plain static text but sometimes we need to show screen multiple times to the subject which contains almost the same content but with a slight changes. To support dynamic parts of the screen content it is piped through Jinja template engine and thus can contain variable parts which are filled when the screen is displayed . For example: As you can see we have used two variables in the screen definition: myparam and upper_bound . These variable can be defined globally at the beginning of the experiment or can be passed as arguments when the screen is displayed like: show AnExampleScreen(myparam hello, upper_bound 10) The screen will be rendered as: This is just a demonstration of parameter rendering inside screen. Here is a param that renders as \"hello\". And here is some looping from 1 to 9 1. Hello world! 2. Hello world! 3. Hello world! 4. Hello world! 5. Hello world! 6. Hello world! 7. Hello world! 8. Hello world! 9. Hello world! Special syntax used to interpolate variable part ( {{}} , {% for ... %} etc.) is defined by Jinja template engine end the full documentation is available on the project site .","title":"Screens"},{"location":"target/","text":"Target configuration Target configuration is optional and is used to configure a target generator. It is specified at the end of the experiment and there can be multiple target configurations as we might have generators for different platforms. The content of the target block is given as a sequence of assignments in the form: <configuration param> = <value> Where configuration parameters are defined by the target generator and should be specified in its documentation. For example: target PsychoPy { background = grey fullScreen = true } See PsychoPy generator for one way how configuration parameters and their default values might be specified. Beside setting some builtin generator parameter like in the example above, target configuration can be used to resolve symbols to target-specific values. target PsychoPy { left = (-0.5, 0) right = (0.5, 0) } Also, you can use scoping to provide different mapping of the symbols in different contexts. target PsychoPy { left = (-0.5, 0) right = (0.5, 0) keyboard.left = left keyboard.right = right } Here, we want symbol left to be mapped to the left position on screen but in the context of the keyboard component it will map to key left .","title":"Target configuration"},{"location":"target/#target-configuration","text":"Target configuration is optional and is used to configure a target generator. It is specified at the end of the experiment and there can be multiple target configurations as we might have generators for different platforms. The content of the target block is given as a sequence of assignments in the form: <configuration param> = <value> Where configuration parameters are defined by the target generator and should be specified in its documentation. For example: target PsychoPy { background = grey fullScreen = true } See PsychoPy generator for one way how configuration parameters and their default values might be specified. Beside setting some builtin generator parameter like in the example above, target configuration can be used to resolve symbols to target-specific values. target PsychoPy { left = (-0.5, 0) right = (0.5, 0) } Also, you can use scoping to provide different mapping of the symbols in different contexts. target PsychoPy { left = (-0.5, 0) right = (0.5, 0) keyboard.left = left keyboard.right = right } Here, we want symbol left to be mapped to the left position on screen but in the context of the keyboard component it will map to key left .","title":"Target configuration"},{"location":"test/","text":"Test definition A test represents the main concept in pyFlies language. Each test has a name, a condition table defining variables and their values for each trial, and component specifications with mapping to trials. On this page we will use an example to show how tests are defined and we will provide references to other pages describing each segment of the definition in more details. Here is an example of a test: The example represents the definition of the Eriksen Flanker task published in: Eriksen, B. A.; Eriksen, C. W. (1974). \"Effects of noise letters upon identification of a target letter in a non- search task\". Perception and Psychophysics. 16: 143\u2013149. The target is flanked by non-target stimuli which correspond either to the same directional response as the target (congruent flankers), or to the opposite response (incongruent flankers). In this example we are using arrows which points to the left or to the right. The surrounding non-target stimuli will be congruent (point to the same direction), or incongruent (point to the opposite direction). Before the test we have three variables defined which we shall use in the test: directions - a list of directions, congruencies - a list of congruencies as each trial can be either congruent or inconguruent, and repeats - a number of repeats we shall use to change the total number of trials during the test run. Test table expansion Values of each trial variable is given as an expression in the table first non-header row. You can see that each expression is a loop expression which will loop over the given sequence to expand the table. Loops are evaluated from left to right, leftmost loop being the top-level outer loop while the rightmost loop being the inner loop. We could also have a sequence without the loop, in which case the sequence would cycle, or any other expression involving global and trail variables and literal values. For repeats value of 1 , as defined globally, this table expands as follow: We could as well write condition table in the expanded style but it would be less flexible as it would be harder to add new variables, to use repetition for total number of trials etc. For the details of condition table specification and expansion see Condition Tables section. Tip Although, pyFlies specifications are just plain textual files and can be edited in any text editor, it is much more convenient to edit tables in editor that supports them, like VS Code pyFlies extension . Components specification The second part of the test definition are mappings of components to trials. These mappings define the components (stimuli and inputs), their timings and conditions under which they should be shown to the subject. These mappings are given in the form: <condition> -> <list of components with timings> where left-hand side (LHS) <condition> is boolean expression which when evaluated to true in the context of the current trial means that the components on the right side are used in the trial. Trial phases For better organization, each trial execution is separated in three phases: fix , exec and error/correct . The phases are executed in succession and for each execution builtin boolean variables fix , exec , error , correct get value of true for corresponding phase, thus those variables can be used in LHS expressions to match the phase. In the above example we have fix -> cross.. . LHS condition is just fix variable which will be true during fix phase of each trial. Thus, cross component will be shown to the subject during each fix phase. If we wanted, for example, to show cross only for odd trials we could write: fix and parity == odd -> cross() for 1000 Notice the part of the definition for 1000 . Each component can optionally define its duration in miliseconds. Here we specify that the cross component will be shown for 1s. If duration is not provided it means indefinitely and the component will last until the end of the phase. We usually use indefinite durations when we have input components which terminate phases on user input. Tip Expressions are used almost everywhere and they can range from just a simple literal value to a more complex expressions using local and global variables. In the exec phase we have two components image and keyboard . First component will display the given image, and the second will wait for the user input. The image component has file defined as variable string created by interpolating direction and category values from the current trial. All strings support powerful templating provided by the Jinja template engine . keyboard component has two parameters: valid - a list of valid keys, and correct - what is considered a correct response. Notice that we have defined valid keys and correct response in abstract terms representing directions. pyFlies tries to capture the essence of the test and thus parameters and variables are defined in abstract terms. The detailed mapping is provided by the code generator and the default mappings can be overriden by the target configuration At the end we specify what will happen in correct and error phases of the trial. We choose to show green or red circle but we could also choose to play sounds, or we could leave these phases out if we don't want it. Remember that correct and error are just boolean variables that are true during phase calculation. Each trial must have components defined for at least exec phase (i.e. evaluation for exec == true must yield components to show). If that is not satisfied the error will be reported during compilation.","title":"Test definition"},{"location":"test/#test-definition","text":"A test represents the main concept in pyFlies language. Each test has a name, a condition table defining variables and their values for each trial, and component specifications with mapping to trials. On this page we will use an example to show how tests are defined and we will provide references to other pages describing each segment of the definition in more details. Here is an example of a test: The example represents the definition of the Eriksen Flanker task published in: Eriksen, B. A.; Eriksen, C. W. (1974). \"Effects of noise letters upon identification of a target letter in a non- search task\". Perception and Psychophysics. 16: 143\u2013149. The target is flanked by non-target stimuli which correspond either to the same directional response as the target (congruent flankers), or to the opposite response (incongruent flankers). In this example we are using arrows which points to the left or to the right. The surrounding non-target stimuli will be congruent (point to the same direction), or incongruent (point to the opposite direction). Before the test we have three variables defined which we shall use in the test: directions - a list of directions, congruencies - a list of congruencies as each trial can be either congruent or inconguruent, and repeats - a number of repeats we shall use to change the total number of trials during the test run.","title":"Test definition"},{"location":"test/#test-table-expansion","text":"Values of each trial variable is given as an expression in the table first non-header row. You can see that each expression is a loop expression which will loop over the given sequence to expand the table. Loops are evaluated from left to right, leftmost loop being the top-level outer loop while the rightmost loop being the inner loop. We could also have a sequence without the loop, in which case the sequence would cycle, or any other expression involving global and trail variables and literal values. For repeats value of 1 , as defined globally, this table expands as follow: We could as well write condition table in the expanded style but it would be less flexible as it would be harder to add new variables, to use repetition for total number of trials etc. For the details of condition table specification and expansion see Condition Tables section. Tip Although, pyFlies specifications are just plain textual files and can be edited in any text editor, it is much more convenient to edit tables in editor that supports them, like VS Code pyFlies extension .","title":"Test table expansion"},{"location":"test/#components-specification","text":"The second part of the test definition are mappings of components to trials. These mappings define the components (stimuli and inputs), their timings and conditions under which they should be shown to the subject. These mappings are given in the form: <condition> -> <list of components with timings> where left-hand side (LHS) <condition> is boolean expression which when evaluated to true in the context of the current trial means that the components on the right side are used in the trial.","title":"Components specification"},{"location":"test/#trial-phases","text":"For better organization, each trial execution is separated in three phases: fix , exec and error/correct . The phases are executed in succession and for each execution builtin boolean variables fix , exec , error , correct get value of true for corresponding phase, thus those variables can be used in LHS expressions to match the phase. In the above example we have fix -> cross.. . LHS condition is just fix variable which will be true during fix phase of each trial. Thus, cross component will be shown to the subject during each fix phase. If we wanted, for example, to show cross only for odd trials we could write: fix and parity == odd -> cross() for 1000 Notice the part of the definition for 1000 . Each component can optionally define its duration in miliseconds. Here we specify that the cross component will be shown for 1s. If duration is not provided it means indefinitely and the component will last until the end of the phase. We usually use indefinite durations when we have input components which terminate phases on user input. Tip Expressions are used almost everywhere and they can range from just a simple literal value to a more complex expressions using local and global variables. In the exec phase we have two components image and keyboard . First component will display the given image, and the second will wait for the user input. The image component has file defined as variable string created by interpolating direction and category values from the current trial. All strings support powerful templating provided by the Jinja template engine . keyboard component has two parameters: valid - a list of valid keys, and correct - what is considered a correct response. Notice that we have defined valid keys and correct response in abstract terms representing directions. pyFlies tries to capture the essence of the test and thus parameters and variables are defined in abstract terms. The detailed mapping is provided by the code generator and the default mappings can be overriden by the target configuration At the end we specify what will happen in correct and error phases of the trial. We choose to show green or red circle but we could also choose to play sounds, or we could leave these phases out if we don't want it. Remember that correct and error are just boolean variables that are true during phase calculation. Each trial must have components defined for at least exec phase (i.e. evaluation for exec == true must yield components to show). If that is not satisfied the error will be reported during compilation.","title":"Trial phases"},{"location":"timing/","text":"Timing specification Timing information can be specified in the following places: Showing a screen for a given duration: show Introduction for 10000 Displaying a component during the test run for a given duration: cross() for 1000 Defining when the component should be shown. For this we use component timing expression which is specified before the component. For example: at .+200 rectangle() This is the general form of the timing expression: at <target:><.><+ or -><miliseconds> where: target: - is the name of the component this expression is relative to. If not given, timing expression is relative to the previous component. . means relative to the start of the target component. If not given time is relative to the end of the previous component. + or - - specified time is relative and is added or subtracted from the target time. <miliseconds> - a number of miliseconds If timing expression is not given for the component, by default it is: at . which means start at the same time as the previous component. Examples: at 200 cross() -- show cross 200ms after the phase begins (this is absolute time) at .-100 cross() -- show cross 100ms before the start of the previous component at +100 cross() -- show cross 100ms after the finish of the previous component at myrec:.+100 cross() -- show cross 100ms after the start of the myrec component at myrec:+100 cross() -- show cross 100ms after the finish of the myrec component at myrec:-100 cross() -- show cross 100ms before the finish of the myrec component","title":"Timing specification"},{"location":"timing/#timing-specification","text":"Timing information can be specified in the following places: Showing a screen for a given duration: show Introduction for 10000 Displaying a component during the test run for a given duration: cross() for 1000 Defining when the component should be shown. For this we use component timing expression which is specified before the component. For example: at .+200 rectangle() This is the general form of the timing expression: at <target:><.><+ or -><miliseconds> where: target: - is the name of the component this expression is relative to. If not given, timing expression is relative to the previous component. . means relative to the start of the target component. If not given time is relative to the end of the previous component. + or - - specified time is relative and is added or subtracted from the target time. <miliseconds> - a number of miliseconds If timing expression is not given for the component, by default it is: at . which means start at the same time as the previous component. Examples: at 200 cross() -- show cross 200ms after the phase begins (this is absolute time) at .-100 cross() -- show cross 100ms before the start of the previous component at +100 cross() -- show cross 100ms after the finish of the previous component at myrec:.+100 cross() -- show cross 100ms after the start of the myrec component at myrec:+100 cross() -- show cross 100ms after the finish of the myrec component at myrec:-100 cross() -- show cross 100ms before the finish of the myrec component","title":"Timing specification"},{"location":"types-expressions/","text":"Types and expressions pyFlies has a type system with a some usual types you can find in other languages, but also some types that are useful in the context of experiments specification. Operations on these types can form complex expressions. You can use expressions in various places of your experiment specification. Types pyFlies values can be of the following types: bool - with values of true and false . You will rarely need to use these values directly. They are usually produced as a results of boolean expression evaluation. For example, an expression direction == right will have a bool value int - is an integer number (e.g. 42 ) float - is a float number (e.g. 3.44 ) point - specifies a location in two dimensional space (e.g. (2, 5) ) color - specifies a color in a standard CSS like notation where we have a # prefix and 6 hex digits, 3 groups of 2 digit where each group represents red , green and blue component of the color (e.g. #455a45 ). string - a string of characters enclosed with quotes (e.g. \"Hello\" ). Strings content is piped through Jinja template engine during evaluation so a powerful string interpolation is available. This interpolation is also done for screens . list - a list of values of any type (e.g. [1, 2, \"hi\", [true, 2.3], left] ) range - is a shorthand for definition of a list with consecutive numbers (e.g. 1..5 ). Usually used for looping in table expansion, or producing a random value from a given range (e.g. 1..100 choose ). symbol - is just a word which might get bound to a value if the variable of the same name is available in the context. If not, a symbol can be mapped to a value by the compiler. Usually used to express abstract terms. For example: directions = [left, right] Here, values in the directions list are symbols whose meaning may be determined by variables or by the compiler. Tip When editing colors in the experiment specification in VS Code editor, various extension from the VS Code marketplace may help. For example Color Manager . Expressions if An expression used to provide a value that depend on a condition. For example: left if cue_pos == right else right So, the form is always: <value if true> if <condition> else <value if false> loop loop expression is used in table expansion . Its form is: <expression> loop where expression evaluates to a list or range. For example: [left, right, up, down] loop Logic Logic operators are: or , not , and and . or and and are standard infix binary operators while not is a standard unary prefix operator: color == blue and not practice Comparison Comparison operators can compare values. They are used as standard infix binary operators. Following operators are supported: == - equal != - not equal <= - less or equals than >= - greater or equals than > - greater than < - less than Arithmetic operators Standard arithmetic operators are supported: + , - , * , / and they work as usual. Randomization Randomization is supported with choose and shuffle operations. These operations are given in a postfix form and are applicable only to lists and ranges. choose will choose a random element from list/range. For example: [red, green, blue] choose 1..100 choose shuffle will produce a list where elements are in a random order. For example: 1..100 shuffle In the current implementation of the compiler all expressions are pre-evaluated by the compilation process. E.g. random values are predetermined at compile time, not run-time. This is done to make generator development easier as otherwise compiler would need to translate all expressions to the target language expressions. This is an implementation detail that might change in the future.","title":"Types and expressions"},{"location":"types-expressions/#types-and-expressions","text":"pyFlies has a type system with a some usual types you can find in other languages, but also some types that are useful in the context of experiments specification. Operations on these types can form complex expressions. You can use expressions in various places of your experiment specification.","title":"Types and expressions"},{"location":"types-expressions/#types","text":"pyFlies values can be of the following types: bool - with values of true and false . You will rarely need to use these values directly. They are usually produced as a results of boolean expression evaluation. For example, an expression direction == right will have a bool value int - is an integer number (e.g. 42 ) float - is a float number (e.g. 3.44 ) point - specifies a location in two dimensional space (e.g. (2, 5) ) color - specifies a color in a standard CSS like notation where we have a # prefix and 6 hex digits, 3 groups of 2 digit where each group represents red , green and blue component of the color (e.g. #455a45 ). string - a string of characters enclosed with quotes (e.g. \"Hello\" ). Strings content is piped through Jinja template engine during evaluation so a powerful string interpolation is available. This interpolation is also done for screens . list - a list of values of any type (e.g. [1, 2, \"hi\", [true, 2.3], left] ) range - is a shorthand for definition of a list with consecutive numbers (e.g. 1..5 ). Usually used for looping in table expansion, or producing a random value from a given range (e.g. 1..100 choose ). symbol - is just a word which might get bound to a value if the variable of the same name is available in the context. If not, a symbol can be mapped to a value by the compiler. Usually used to express abstract terms. For example: directions = [left, right] Here, values in the directions list are symbols whose meaning may be determined by variables or by the compiler. Tip When editing colors in the experiment specification in VS Code editor, various extension from the VS Code marketplace may help. For example Color Manager .","title":"Types"},{"location":"types-expressions/#expressions","text":"","title":"Expressions"},{"location":"types-expressions/#if","text":"An expression used to provide a value that depend on a condition. For example: left if cue_pos == right else right So, the form is always: <value if true> if <condition> else <value if false>","title":"if"},{"location":"types-expressions/#loop","text":"loop expression is used in table expansion . Its form is: <expression> loop where expression evaluates to a list or range. For example: [left, right, up, down] loop","title":"loop"},{"location":"types-expressions/#logic","text":"Logic operators are: or , not , and and . or and and are standard infix binary operators while not is a standard unary prefix operator: color == blue and not practice","title":"Logic"},{"location":"types-expressions/#comparison","text":"Comparison operators can compare values. They are used as standard infix binary operators. Following operators are supported: == - equal != - not equal <= - less or equals than >= - greater or equals than > - greater than < - less than","title":"Comparison"},{"location":"types-expressions/#arithmetic-operators","text":"Standard arithmetic operators are supported: + , - , * , / and they work as usual.","title":"Arithmetic operators"},{"location":"types-expressions/#randomization","text":"Randomization is supported with choose and shuffle operations. These operations are given in a postfix form and are applicable only to lists and ranges. choose will choose a random element from list/range. For example: [red, green, blue] choose 1..100 choose shuffle will produce a list where elements are in a random order. For example: 1..100 shuffle In the current implementation of the compiler all expressions are pre-evaluated by the compilation process. E.g. random values are predetermined at compile time, not run-time. This is done to make generator development easier as otherwise compiler would need to translate all expressions to the target language expressions. This is an implementation detail that might change in the future.","title":"Randomization"},{"location":"about/contributing/","text":"pyFlies is open for contributions. You can contribute code, documentation, tests, bug reports. If you plan to make a contribution it would be great if you first announce that on the discussion forum. For bug reports please use github issue tracker . For code/doc/test contributions do the following: Fork the project on github . Clone your fork. Make a branch for the new feature and switch to it. Make one or more commits. Push your branch to github. Make a pull request. I will look at the changes and if everything is ok I will pull it in. Note For code contributions please try to adhere to the PEP-8 guidelines . Although we are not strict in that regard it is useful to have a common ground for coding style. To make things easier use tools for code checking (PyLint, PyFlakes, pep8 etc.).","title":"Contributing"},{"location":"about/license/","text":"Copyright (c) Igor Dejanovi\u0107 This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/ .","title":"License"},{"location":"about/release_notes/","text":"Release notes You can find release notes on the GitHub Releases page .","title":"Release Notes"},{"location":"about/release_notes/#release-notes","text":"You can find release notes on the GitHub Releases page .","title":"Release notes"}]}