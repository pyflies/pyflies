{# vim: filetype=django tabstop=4 shiftwidth=4 expandtab
-#}
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
{{m.name}}
---------------------

{{m.description}}

This test was generated by pyFlies(https://github.com/igordejanovic/pyFlies) on {{datetime}}
If you are going to regenerate this file from the pyFlies model again
do not edit it manually or else your manual changed will be lost.
"""

from random import shuffle, randint
from collections import namedtuple
from expyriment import design, control, stimuli, io, misc


class Block(list):
    def __init__(self):
        super(list, self).__init__()
        # Is this block a test
        self._test = True
        # Standard stimuli
        self._fix = []
        self._error = []
        self._correct = []

# Response map
response_map = {
    {% for r in target.responseMap -%}
    "{{r.name}}": misc.constants.{{r.target}},
    {% endfor %}
}

# Reverse map button->reponse. Used in data logging.
button_response_map = {
    {% for r in target.responseMap -%}
    misc.constants.{{r.target}}: "{{r.name}}",
    {% endfor %}
}

{%- macro stimulus(s) %}
  {%- if s._typename == "Shape" %}
    {%- if s.shape == "circle" %}
s = stimuli.Circle(size=({{s.width}}, {{s.height}}), colour=misc.constants.{{color_map[s.color]}}, position=({{s.x}}, {{s.y}}))
    {%- elif s.shape == "rectangle"%}
s = stimuli.Rectangle(size=({{s.width}}, {{s.height}}), colour=misc.constants.{{color_map[s.color]}}, position=({{s.x}}, {{s.y}}))
    {%- elif s.shape == "cross"%}
s = stimuli.FixCross(size=({{s.width}}, {{s.height}}), colour=misc.constants.{{color_map[s.color]}}, position=({{s.x}}, {{s.y}}))
    {%- endif %}
  {%- elif s._typename == "Text" %}
s = stimuli.TextLine("{{s.text}}", text_size={{s.width}}, text_colour=misc.constants.{{color_map[s.color]}}, position=({{s.x}}, {{s.y}}))
  {%- elif s._typename == "Image" %}
s = stimuli.Picture("{{s.file}}")
  {%- elif s._typename == "Sound" %}
s = stimuli.Tone({{s.dmin}}, {{s.frequency}})
  {%- elif s._typename == "Audio" %}
s = stimuli.Audio("{{s.file}}")
  {%- endif %}
s.dmin = {{s.dmin}}
s.dmax = {{s.dmax}}
{%- endmacro %}

# Create experiment
exp = design.Experiment("{{m.name}}")

# Initialize an Experiment
control.initialize(exp)

{% for b in m.blocks -%}
  {%- if b._typename == "Test" %}
# {{b.name}} test
  {%- endif %}
{{b.name}} = Block()
  {%- if b._typename == "Screen" %}
t = design.Trial()
s = stimuli.TextScreen("Instructions", """{{b.content|striptabs}}""")
s.preload()
t.add_stimulus(s)
{{b.name}}.append(t)
  {% elif b._typename == "Test" %}
# FIXME: This is per experiment. How to specify variable names per block?
factor_names = [{% for v in b.conditions.varNames %}"{{v}}", {% endfor %}]
data_variable_names = factor_names[:]
data_variable_names.extend(["rt", "error", "practice"])
    {%- for c in b.conditions.conditions %}
      {%- if c.stimuli_for_cond %}

# Create and preload simuli for condition {{loop.index}} of {{b.name}} test
# {{c.varValues|join(", ")}}
t = design.Trial()
# Trial factors
        {%- for factor in b.conditions.varNames %}
t.set_factor("{{factor}}", "{{c.varValues[loop.index-1]}}")
        {%- endfor %}
# Stimuli
        {%- for s in c.stimuli_for_cond[0] %}
        {{- stimulus(s) }}
s.preload()
t.add_stimulus(s)
        {%- endfor %}
{{b.name}}.append(t)
      {%- endif %}
    {%- endfor %}

    {%- if b._error %}

# Stimuli for signalizing erroneous response
      {%- for s in b._error %}
        {{- stimulus(s) }}
s.preload()
{{b.name}}._error.append(s)
      {%- endfor %}
    {%- endif %}
    {%- if b._correct %}

# Stimuli for signalizing correct response
      {%- for s in b._correct %}
        {{- stimulus(s) }}
s.preload()
{{b.name}}._correct.append(s)
      {%- endfor %}
    {%- endif %}
    {%- if b._fix %}

# Fixation stimuli
      {%- for s in b._fix %}
        {{- stimulus(s) }}
s.preload()
{{b.name}}._fix.append(s)
      {%- endfor %}
    {%- endif %}
  {%- endif %}
{%- endfor %}

BlockParam = namedtuple('BlockParams', ['practice', 'test', 'dmin', 'dmax', 'fix', 'error', 'correct' ])
block_param_map = {}


def create_instance(b, name, dmin=None, dmax=None, repeat=1, practice=False, test=False):
    block = design.Block(name)
    block_param_map[name] = BlockParam(
        practice=practice, test=test, dmin=dmin, dmax=dmax, fix=b._fix, error=b._error, correct=b._correct)
    for t in b:
        block.add_trial(t, copies=repeat)
    block.shuffle_trials()
    return block


def build_experiment(exp, blocks, name):

    def _randomize(blocks):
        """
        Recursively traverse experiment structure and randomize all
        Randomize blocks (lists).
        """
        for b in blocks:
            if type(b) is list:
                shuffle(b)
            if type(b) in (list, tuple):
                _randomize(b)

    def _flatten(blocks):
        """
        Flattens blocks nested structure.
        """
        flattened = []
        for b in blocks:
            if type(b) in (list, tuple):
                flattened.extend(_flatten(b))
            else:
                flattened.append(b)
        return flattened

    _randomize(blocks)
    for b in _flatten(blocks):
        exp.add_block(b)

# Experiment structure
blocks = [
{%- for e in m.structure.elements recursive -%}
  {%- if e._typename == "Sequence" %}
    ( {{ loop(e.elements) }} ),
  {%- elif e._typename == "Randomize" %}
    [ {{ loop(e.elements) }} ],
  {%- else -%}
    create_instance({{e.type.name}}, "{{e.type.name}}-{{e._position}}"{% if e._typename == "TestInstance"%}, {{e.type.stimuli.dmin}}, {{e.type.stimuli.dmax}}, {{e.trials}}, {{e.practice}}, True{% endif %}),
  {%- endif -%}
{%- endfor -%}
]

build_experiment(exp, blocks, "{{m.name}}")

response_device = exp.keyboard
exp.data_variable_names = data_variable_names

blank_screen = stimuli.BlankScreen()
blank_screen.preload()

# Start Experiment
control.start(exp)

for block in exp.blocks:
    bparam = block_param_map.get(block.name)
    practice = 1 if bparam.practice else 0
    for trial in block.trials:
        # Present fixation if defined
        if bparam and bparam.fix:
            for s in bparam.fix:
                s.present()
                exp.clock.wait(randint(s.dmin, s.dmax))
                # FIXME: Stimuli can't be presented concurrently in Expyriment
                break

        if bparam and bparam.test and not bparam.fix:
            blank_screen.present()

        for stimulus in trial.stimuli:
            stimulus.present()
            #exp.clock.wait(randint(stimulus.dmin, stimulus.dmax))
            # FIXME: Stimuli can't be presented concurrently in Expyriment
            break

        if bparam and bparam.test:
            response_keys = [key for key in button_response_map if button_response_map[key]!='next']
            button, rt = response_device.wait(response_keys)
            error = 0
            if bparam and (bparam.error or bparam.correct):
                # Check if response is correct
                if button == response_map[trial.get_factor("response")]:
                    if bparam.correct:
                        for s in bparam.correct:
                            s.present()
                            exp.clock.wait(randint(s.dmin, s.dmax))
                            # FIXME: Stimuli can't be presented concurrently in Expyriment
                            break
                else:
                    error = 1
                    if bparam.error:
                        for s in bparam.error:
                            s.present()
                            exp.clock.wait(randint(s.dmin, s.dmax))
                            # FIXME: Stimuli can't be presented concurrently in Expyriment
                            break

            if bparam:
                response = button_response_map[button]
                data = []
                for name in factor_names:
                    if name == "response":
                        data.append(response)
                    else:
                        data.append(trial.factor_dict[name])
                data.extend([rt, error, practice])
                exp.data.add(data)
        else:
            # If not a test
            if 'next' in response_map:
                button, rt = response_device.wait([response_map['next']])
            else:
                button, rt = response_device.wait([misc.constants.K_SPACE])

control.end()

